---
title: "ALS-bloodplasama-miRNA"
author: "César Esparza"
date: "2025-05-07"
output: html_document
---

```{r}
library(tidyverse)
library(pheatmap)
library(readr)
library(dplyr)
library(stringr)
library(ggplot2)
library(purrr)

```

```{r}
# 2) Read the table
df <- read_tsv("/Users/cesaresparza/New_Desktop/UCSD/8OG/results/Magen_ALS-bloodplasma/miRNA_count.Q33.txt", col_types = cols())

# 3) Identify metadata vs. data columns
meta_cols   <- c("miRNA name", "pos:mut")
data_cols   <- setdiff(names(df), meta_cols)

#  - Total‐count columns have "(PM+1MM+2MM)" in their names
total_cols  <- grep("\\(PM\\+1MM\\+2MM\\)", data_cols, value = TRUE)
#  - SNV‐specific columns are the rest
snv_cols    <- setdiff(data_cols, total_cols)

```




```{r}
#Chunk 3
# 1. split_mutations: expande variantes en filas separadas
split_mutations <- function(df, mut_col = "pos:mut") {
  df %>%
    separate_rows(.data[[mut_col]], sep = ",") %>%
    mutate(!!mut_col := str_trim(.data[[mut_col]]))
}

# 2. collapse_after_split: suma sólo las columnas SNV (snv_cols)
collapse_after_split <- function(df, mut_col = "pos:mut", count_cols = snv_cols) {
  df %>%
    group_by(.data[["miRNA name"]], .data[[mut_col]]) %>%
    summarise(across(all_of(count_cols), sum), .groups = "drop") %>%
    rename(miRNA_name = `miRNA name`)
}


# 3. convert_to_edgeR: arma featureID y matriz entera para edgeR
convert_to_edgeR <- function(df_collapsed, mut_col = "pos:mut", count_cols = snv_cols) {
  df_DE <- df_collapsed %>%
    mutate(
      clean_mut  = str_replace_all(.data[[mut_col]], ":", "_"),
      featureID  = paste(miRNA_name, clean_mut, sep = "_")
    ) %>%
    select(featureID, all_of(count_cols))
  
  count_mat <- as.matrix(df_DE[count_cols])
  rownames(count_mat) <- df_DE$featureID
  mode(count_mat) <- "integer"
  
  stopifnot(exists("count_mat"))
  stopifnot(!any(is.na(count_mat)))
  cat("Dimensions of count_mat:", dim(count_mat), 
      "(rows = variants, cols = samples)\n")
  
  return(count_mat)
}


```

```{r}
## Chunk_4 {RPM_Functions}

# 1) Annotate_total_counts:
#    From your full df, grab just the PM rows (one per miRNA) and keep only
#    the miRNA name + the “(PM+1MM+2MM)” columns -> a wide table of raw counts.
Annotate_total_counts <- function(df,
                                  total_cols,
                                  miRNA_col = "miRNA name",
                                  mut_col   = "pos:mut") {
  df %>%
    filter(.data[[mut_col]] == "PM") %>%
    select(miRNA = .data[[miRNA_col]], all_of(total_cols))
}


# 2) Calculate_total_per_sample:
#    Take that counts table, sum each sample‐column, and append a final row
#    named “totals” (so you can use it as the denominator later).
Calculate_total_per_sample <- function(count_df) {
  totals <- count_df %>%
    select(-miRNA) %>%
    summarise(across(everything(), ~ sum(.x, na.rm = TRUE))) %>%
    mutate(miRNA = "totals") %>%
    select(miRNA, everything())
  
  bind_rows(count_df, totals)
}


# 3) Calculate_RPM:
#    Using the “totals” row as denominator, divide every miRNA count by its
#    sample’s total, multiply by 1e6, and return a table of the same shape
#    (minus the totals row).
Calculate_RPM <- function(count_df,
                          miRNA_col = "miRNA",
                          factor     = 1e6) {
  # pull out denominators as named numeric vector
  denom <- count_df %>%
    filter(.data[[miRNA_col]] == "totals") %>%
    select(-all_of(miRNA_col)) %>%
    unlist(use.names = TRUE)
  
  # drop totals row, then normalize
  count_df %>%
    filter(.data[[miRNA_col]] != "totals") %>%
    mutate(across(-all_of(miRNA_col),
                  ~ .x / denom[cur_column()] * factor))
}


#Separate_by_batch <- function(rpm_df,
 #                             sample_info,
  #                            suffix     = " (PM+1MM+2MM)",
   #                           miRNA_col  = "miRNA") {
  # Reconstruct parts 2 & 3 from the raw sample string
  #si <- sample_info %>%
   #  parts     = str_split(sample, "-", simplify = TRUE),
     #part3     = parts[,3],    # "longitudinal_xx" or "enrolment" or others
      #cohort    = case_when(
    #    part2 == "control"                                                           ~ "control",
     #   part2 == "ALS" & str_detect(part3, regex("^longitudinal", ignore_case=TRUE)) ~ "als_longitudinal",
      #  part2 == "ALS"                                                               ~ "als_enrolment",
       # TRUE                                                                         ~ NA_character_
     # ),
     # colname   = paste0(sample, suffix)
    #)
  
  # Grab exactly those suffixed column names for each cohort
  #ctrl_cols  <- si %>% filter(cohort == "control")         %>% pull(colname)
  #enr_cols   <- si %>% filter(cohort == "als_enrolment")   %>% pull(colname)
  #long_cols  <- si %>% filter(cohort == "als_longitudinal")%>% pull(colname)
  
  # Subset rpm_df accordingly
  #list(
   # control           = rpm_df %>% select(all_of(c(miRNA_col, ctrl_cols))),
   # als_enrolment     = rpm_df %>% select(all_of(c(miRNA_col, enr_cols))),
    #als_longitudinal  = rpm_df %>% select(all_of(c(miRNA_col, long_cols)))
  #)
#}

Separate_by_group <- function(rpm_df,
                              sample_info,
                              suffix    = " (PM+1MM+2MM)",
                              miRNA_col = "miRNA") {
  si <- sample_info %>%
    mutate(
      parts   = str_split(sample, "-", simplify = TRUE),
      # part2 is always "control" or "ALS"
      part2   = parts[,2],
      cohort  = if_else(part2 == "ALS", "ALS", "control"),
      colname = paste0(sample, suffix)
    )
  
  ctrl_cols <- si %>% filter(cohort == "control") %>% pull(colname)
  als_cols  <- si %>% filter(cohort == "ALS")     %>% pull(colname)
  
  list(
    control = rpm_df %>% select(all_of(c(miRNA_col, ctrl_cols))),
    ALS     = rpm_df %>% select(all_of(c(miRNA_col, als_cols)))
  )
}


# 5) Threshold_binary_and_select:
#    Turn any RPM table into 0/1 by a given threshold, then pull out the miRNAs
#    that have “1” in at least a given fraction of samples.
Threshold_binary_and_select <- function(rpm_df,
                                       threshold     = 1,
                                       min_fraction  = 0.10,
                                       miRNA_col     = "miRNA") {
  samp_cols <- setdiff(names(rpm_df), miRNA_col)
  # 0/1 matrix
  binary <- rpm_df %>%
    mutate(across(all_of(samp_cols),
                  ~ as.integer(.x >= threshold)))
  
  # count 1’s per miRNA
  n_samps <- length(samp_cols)
  min_samps <- ceiling(n_samps * min_fraction)
  keep <- binary %>%
    mutate(n_ones = rowSums(select(., all_of(samp_cols)))) %>%
    filter(n_ones >= min_samps) %>%
    pull(all_of(miRNA_col))
  
  list(
    binary_matrix   = binary %>% select(miRNA, all_of(samp_cols)),
    selected_miRNAs = keep
  )
}


```

```{r}
## Chunk_2 {Initial_Exploration}
# --- Load sample_info and group definitions ---
sample_info <- tibble(sample = snv_cols) %>%
  mutate(parts = str_split(sample, "-", simplify = TRUE),
         group = case_when(
           parts[,2] == "control" ~ "control",
           str_detect(parts[,3], regex("^longitudinal", ignore_case=TRUE)) ~ "longitudinal",
           TRUE ~ "als"
         )) %>%
  mutate(group = factor(group, levels = c("control","als","longitudinal")))

# Get vector of samples per group
ctrl_samps  <- sample_info %>% filter(group=="control")      %>% pull(sample)
als_samps   <- sample_info %>% filter(group=="als")          %>% pull(sample)
long_samps  <- sample_info %>% filter(group=="longitudinal") %>% pull(sample)

ctrl_pm_cols  <- paste0(ctrl_samps, " (PM+1MM+2MM)")
als_pm_cols   <- paste0(als_samps,  " (PM+1MM+2MM)")
long_pm_cols  <- paste0(long_samps, " (PM+1MM+2MM)")

# 1) Samples per group (bar chart)
counts <- sample_info %>% count(group, name = "n_samples")
print(counts)
ggplot(counts, aes(x = group, y = n_samples, fill = group)) +
  geom_col() +
  geom_text(aes(label = n_samples), vjust = -0.5) +
  scale_x_discrete(limits = c("control","als","longitudinal")) +
  scale_fill_manual(values = c(control="steelblue", als="grey80", longitudinal="grey60")) +
  labs(title = "Number of samples per group", x = NULL, y = "Samples") +
  theme_minimal() + theme(legend.position = "none")

# 2a) Diversity of miRNAs per sample (presence/absence of PM) & stats by group
# Filter for PM rows
 df_PM <- df %>% filter(`pos:mut` == "PM")
# Presence matrix and count per sample
div_per_sample <- df_PM %>%
  select(all_of(total_cols)) %>%
  mutate(across(everything(), ~ .x > 0)) %>%
  summarise(across(everything(), sum)) %>%
  pivot_longer(cols = everything(), names_to = "sample", values_to = "n_miRNAs")
# Add group
div_df <- div_per_sample %>% left_join(sample_info, by = "sample")
# Stats per group
stats_div <- div_df %>%
  group_by(group) %>%
  summarise(mean_div = mean(n_miRNAs), sd_div = sd(n_miRNAs))
print(stats_div)
# Boxplot per group
ggplot(div_df, aes(x = group, y = n_miRNAs, fill = group)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.1, outlier.size = 0.5) +
  scale_x_discrete(limits = c("control","als","longitudinal")) +
  scale_fill_manual(values = c(control="steelblue", als="grey80", longitudinal="grey60")) +
  labs(title = "Diversity of miRNAs per sample by group", x = NULL, y = "# miRNAs detected") +
  theme_minimal() + theme(legend.position = "none")

# 2b) Abundance of miRNAs per sample (sum of PM counts)
abundance_per_sample <- df_PM %>%
  select(all_of(total_cols)) %>%
  summarise(across(everything(), sum)) %>%
  pivot_longer(cols = everything(), names_to = "sample", values_to = "total_counts")
abun_df <- abundance_per_sample %>% left_join(sample_info, by = "sample")
stats_abun <- abun_df %>%
  group_by(group) %>%
  summarise(mean_abun = mean(total_counts), sd_abun = sd(total_counts))
print(stats_abun)
# Barplot with error bars
ggplot(stats_abun, aes(x = group, y = mean_abun, fill = group)) +
  geom_col() +
  geom_errorbar(aes(ymin = mean_abun - sd_abun, ymax = mean_abun + sd_abun), width = 0.2) +
  scale_x_discrete(limits = c("control","als","longitudinal")) +
  scale_fill_manual(values = c(control="steelblue", als="grey80", longitudinal="grey60")) +
  labs(title = "Average miRNA counts per sample by group", x = NULL, y = "Mean total counts") +
  theme_minimal() + theme(legend.position = "none")

# 3) miRNA diversity per sample (points)
ggplot(div_df, aes(x = sample, y = n_miRNAs, color = group)) +
  geom_point() +
  scale_color_manual(values = c(control="steelblue", als="grey80", longitudinal="grey60")) +
  theme_minimal() +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  labs(title = "miRNA diversity per individual sample", x = NULL, y = "# miRNAs detected")

# 4) Average SNVs per miRNA by group (presence/absence matrix)
collapsed <- collapse_after_split(df)
# Presence/absence
snv_presence <- collapsed %>% mutate(across(all_of(snv_cols), ~ .x > 0))
# Count SNVs per miRNA per sample
snv_counts <- snv_presence %>%
  pivot_longer(all_of(snv_cols), names_to = "sample", values_to = "present") %>%
  filter(present) %>%
  left_join(sample_info, by = "sample") %>%
  group_by(`miRNA name`, sample, group) %>%
  summarise(n_SNVs = n(), .groups = "drop")
# Stats per group
snv_stats <- snv_counts %>%
  group_by(group) %>%
  summarise(mean_SNVs = mean(n_SNVs), sd_SNVs = sd(n_SNVs))
print(snv_stats)
# Barplot with error bars
ggplot(snv_stats, aes(x = group, y = mean_SNVs, fill = group)) +
  geom_col() +
  geom_errorbar(aes(ymin = mean_SNVs - sd_SNVs, ymax = mean_SNVs + sd_SNVs), width = 0.2) +
  scale_x_discrete(limits = c("control","als","longitudinal")) +
  scale_fill_manual(values = c(control="steelblue", als="grey80", longitudinal="grey60")) +
  labs(title = "Average SNVs per miRNA by group", x = NULL, y = "Mean SNVs per miRNA") +
  theme_minimal() + theme(legend.position = "none")

# 5) SNV prevalence histogram by group
snv_prev <- snv_presence %>%
  mutate(
    n_ctrl = rowSums(across(all_of(ctrl_samps)) > 0),
    n_als  = rowSums(across(all_of(als_samps))  > 0),
    n_long = rowSums(across(all_of(long_samps)) > 0)
  ) %>%
  pivot_longer(c(n_ctrl,n_als,n_long), names_to = "group", values_to = "n_samples") %>%
  mutate(group = recode(group, n_ctrl = "control", n_als = "als", n_long = "longitudinal"))
# Faceted histogram
ggplot(snv_prev, aes(x = n_samples)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "white") +
  facet_wrap(~ group, scales = "free_y", nrow = 1) +
  labs(title = "SNV prevalence across samples by group", x = "Samples with SNV", y = "Count of SNVs") +
  theme_minimal()
  
```

```{r}
## --- split & collapse -------------------------------------------
df_split      <- split_mutations(df)                     # explode comma-separated muts
df_collapsed  <- collapse_after_split(df_split)          # sum counts per miR+mut
```
```{r}
df_collapsed
```


```{r}
## --- RPM, group split & miRNA selection -------------------------

# (a) total-count matrix (PM rows only)  →  RPM table
pm_counts  <- Annotate_total_counts(df, total_cols)
pm_totals  <- Calculate_total_per_sample(pm_counts)
rpm_tab    <- Calculate_RPM(pm_totals)                   # miRNA × sample RPMs

# (b) split RPMs into control / ALS
grp_rpms   <- Separate_by_group(rpm_tab, sample_info)    # list(control, ALS)

# (c) pick miRNAs present at ≥1 RPM in ≥10 % of samples (group-specific)
ctrl_keep  <- Threshold_binary_and_select(grp_rpms$control,
                                          threshold = 1,  min_fraction = 0.10)$selected_miRNAs
ALS_keep   <- Threshold_binary_and_select(grp_rpms$ALS,
                                          threshold = 1,  min_fraction = 0.10)$selected_miRNAs
```

```{r}
## --- tag keep_miRNA & filter by presence -----------------------

# A helper to build a filtered data-frame for ONE group
build_group_df <- function(miR_keep_vec, grp_label) {

  #   1  flag rows that pass the RPM filter
  df_tag <- df %>%
    mutate(keep_miRNA = `miRNA name` %in% miR_keep_vec)

  #   2  retain only those miRNAs (PM + SNV rows)
  df_rpm <- Filter_df_by_RPM(df_tag)

  #   3  restrict to columns of this group
  samp_vec   <- sample_info %>% filter(group == grp_label) %>% pull(sample)
  snv_cols_g <- samp_vec                                 # SNV counts cols
  all_cols   <- c("miRNA name", "pos:mut", samp_vec,     # keep metadata + counts
                  paste0(samp_vec, " (PM+1MM+2MM)"))

  df_rpm %>%
    select(all_of(all_cols)) %>%                         # drop other groups’ cols
    Filter_SNVs_by_presence(snv_cols = snv_cols_g,       # prevalence ≥10 %
                            min_fraction = 0.10)
}

df_ctrl_final <- build_group_df(ctrl_keep, "control")
df_ALS_final  <- build_group_df(ALS_keep,  "als")
```



```{r}
## ── Chunk A : long table with variant frequencies (versión corregida) ──
library(glue)     # para el warning
library(tidyr)    # asegura separate_rows()

# ── 1 ── total reads (PM+1MM+2MM) por miRNA × muestra ────────────────────
tot_long <- df %>%
  filter(`pos:mut` == "PM") %>%
  select(`miRNA name`, all_of(total_cols)) %>%
  pivot_longer(-`miRNA name`,
               names_to  = "tot_col",
               values_to = "tot_reads") %>%
  mutate(sample = str_remove(tot_col, " \\(PM\\+1MM\\+2MM\\)$")) %>%
  select(miRNA = `miRNA name`, sample, tot_reads)

# ── 2 ── helper: tabla long con cuentas SNV (una fila = 1 SNV en 1 muestra) ─
snv_long_counts <- function(df_final, grp) {

  intended  <- sample_info %>% filter(group == grp) %>% pull(sample)
  samp_cols <- intersect(intended, names(df_final))

  if (length(samp_cols) == 0) {
    warning(glue("No remaining sample columns for group '{grp}'."))
    return(tibble())
  }

  df_final %>%
    separate_rows(`pos:mut`, sep = ",") %>%        # ★ rompe compuestos
    filter(`pos:mut` != "PM") %>%
    pivot_longer(all_of(samp_cols),
                 names_to  = "sample",
                 values_to = "snv_reads") %>%
    filter(snv_reads > 0) %>%
    mutate(group   = grp,
           miRNA   = `miRNA name`,
           pos_num = as.numeric(str_extract(`pos:mut`, "^[0-9]+")),       # posición
           mut     = str_extract(`pos:mut`, "(?<=:)[ACGT]{2}"),           # ej.  GT
           ref     = substr(mut, 1, 1),
           alt     = substr(mut, 2, 2),
           mut_type = paste0(ref, ">", alt)) %>%
    select(group, miRNA, `pos:mut`, pos_num, mut_type,
           sample, snv_reads)
}

# ── 3 ── une control + ALS y calcula frecuencia ──────────────────────────
snv_all_freq <- bind_rows(
  snv_long_counts(df_ctrl_final, "control"),
  snv_long_counts(df_ALS_final,  "als")
) %>%
  left_join(tot_long, by = c("miRNA", "sample")) %>%
  mutate(freq = snv_reads / (snv_reads + tot_reads))
```

```{r}
## ── Chunk E : remove SNVs with median freq > 0.30 in any cohort ──────────
freq_cut <- 0.30      # change here if you want 0.25, 0.20, …

snv_median <- snv_all_freq %>%
  group_by(group, `pos:mut`) %>%
  summarise(med_freq = median(freq,  na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = group, values_from = med_freq, values_fill = 0)

snv_keep <- snv_median %>%
  filter(control <= freq_cut,
         als      <= freq_cut) %>%            # drop if either side > cut
  pull(`pos:mut`)

snv_all_clean <- snv_all_freq %>%
  filter(`pos:mut` %in% snv_keep)

cat("SNVs retained :", n_distinct(snv_keep), "\n")
```

```{r}
## ── Chunk B : substitution spectrum (whole miRNA) ───────────────────────
whole_spec <- snv_all_freq %>%
  group_by(group, mut_type) %>%
  summarise(mean_freq = mean(freq, na.rm = TRUE),
            .groups   = "drop")

ggplot(whole_spec, aes(mut_type, mean_freq, fill = group)) +
  geom_col(position = "dodge") +
  labs(title = "Mean fractional abundance by substitution (whole miRNA)",
       x = "Substitution", y = "mean SNV frequency") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
## ── Chunk C : substitution spectrum (seed 2-7) ──────────────────────────
seed_spec <- snv_all_freq %>%
  filter(pos_num >= 2, pos_num <= 7) %>%
  group_by(group, mut_type) %>%
  summarise(mean_freq = mean(freq, na.rm = TRUE),
            .groups   = "drop")

ggplot(seed_spec, aes(mut_type, mean_freq, fill = group)) +
  geom_col(position = "dodge") +
  labs(title = "Mean fractional abundance by substitution (seed 2-7)",
       x = "Substitution", y = "mean SNV frequency") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```



```{r}
## ── Chunk F : top-20 seed SNVs (after high-freq filter) ──────────────────
top_seed_clean <- snv_all_clean %>%
  filter(pos_num >= 2, pos_num <= 7) %>%
  group_by(group, `pos:mut`) %>%
  summarise(med_freq = median(freq, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = group,
              values_from = med_freq,
              values_fill = 0) %>%
  arrange(desc(als)) %>%
  slice_head(n = 20)

ggplot(top_seed_clean,
       aes(reorder(`pos:mut`, als), als)) +
  geom_linerange(aes(ymin = control, ymax = als), colour = "grey40") +
  geom_point(size = 3, colour = "firebrick") +
  coord_flip() +
  labs(title    = "Top-20 seed SNVs (median freq) – high-freq removed",
       subtitle = glue::glue("Threshold = {freq_cut*100}% median in either cohort"),
       x = NULL, y = "median frequency in ALS") +
  theme_minimal()
```
```{r}
## ── Chunk G : miRNAs ranked by G>T seed load ────────────────────────────
seed_gt <- snv_all_freq %>%                           # use full freq table
  filter(mut_type == "G>T", pos_num >= 2, pos_num <= 7) %>%
  group_by(group, miRNA) %>%
  summarise(
    mean_freq = mean(freq, na.rm = TRUE),             # average across samples
    prevalence = n(),                                 # # sample‑occurrences
    .groups = "drop"
  )

# top 15 miRNAs by mean G>T freq in ALS
top_gt_als <- seed_gt %>%
  filter(group == "als") %>%
  arrange(desc(mean_freq)) %>%
  slice_head(n = 15)

top_gt_als
```

```{r}
## ── Chunk G : miRNAs con mayor carga G>T en semilla ─────────────────────
gt_seed <- snv_all_clean %>%                     # usa _clean o _freq según prefieras
  filter(mut_type == "G>T",                      # sólo G>T
         pos_num >= 2, pos_num <= 7)             # sólo nt 2‑7 (semilla)

miR_gt <- gt_seed %>%
  group_by(group, miRNA) %>%
  summarise(total_Gt_reads = sum(snv_reads),     # suma de lecturas
            mean_freq      = mean(freq),         # frecuencia media del SNV
            .groups = "drop") %>%
  arrange(desc(total_Gt_reads)) %>%
  group_by(group) %>%
  slice_head(n = 15)                             # top‑15 por cohorte

ggplot(miR_gt,
       aes(x = reorder(miRNA, total_Gt_reads),
           y = total_Gt_reads, fill = group)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  facet_wrap(~ group, scales = "free_y") +
  labs(title = "Top 15 miRNAs with highest G>T concentration in seed region (nt 2_7)",
       x = NULL, y = "accumulated G>T ") +
  theme_minimal()
```

```{r}
## ── Chunk H : G>T por posición 2‑7 (frecuencia media) ───────────────────
gt_dyn <- snv_all_clean %>%
  filter(mut_type == "G>T",
         pos_num >= 2, pos_num <= 7) %>%
  group_by(group, pos_num) %>%
  summarise(mean_freq = mean(freq),
            .groups   = "drop")

ggplot(gt_dyn,
       aes(x = pos_num, y = mean_freq, colour = group)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  scale_x_continuous(breaks = 2:7) +
  labs(title = "Average freq of G>T in seed region (2 7 nt)",
       x = "position (nt 2‑7)",
       y = "avg freq of SNV") +
  theme_minimal()
```

```{r}
str(mat, vec.len = 3)        # imprime los primeros 3 valores de cada columna
any(sapply(mat, is.numeric)) # comprueba al vuelo
```

```{r}
## STEP 1 ── matriz G>T (freq) --------------------------------------------
gt_mat <- snv_all_clean %>%                           # usa _clean o _freq
  filter(mut_type == "G>T",
         pos_num >= 1, pos_num <= 22) %>%             # ⇠ cámbialo a 2-7 si quieres
  group_by(sample, pos_num) %>%
  summarise(freq = sum(freq), .groups = "drop") %>%
  pivot_wider(names_from  = pos_num,
              values_from = freq,
              values_fill = 0) %>%                    # NA → 0
  arrange(sample)

m <- gt_mat %>%
  column_to_rownames("sample") %>%
  as.matrix()

stopifnot(is.numeric(m))                              # debe ser numérico
cat("matrix dims =", dim(m), ";  range =", range(m), "\n")
```

```{r}
# 1) Matriz filas = SNV (miRNA_pos:mut), columnas = muestras
gt_mat_df_all <- snv_all_clean %>%                   # ← o snv_all_freq
  filter(mut_type == "G>T") %>%                      # SIN filtrar por pos_num
  mutate(snv_id = paste(miRNA, `pos:mut`, sep = "_")) %>%
  group_by(sample, snv_id) %>%
  summarise(freq = sum(freq), .groups = "drop") %>%
  pivot_wider(names_from  = sample,
              values_from = freq,
              values_fill = 0) %>%                   # NA → 0
  arrange(snv_id)

mat_all <- gt_mat_df_all %>%
  column_to_rownames("snv_id") %>%
  as.matrix()

stopifnot(is.numeric(mat_all))
cat("dims SNV×sample (full) :", dim(mat_all), "\n")

# 2) Dendrogramas euclidianos
rowClust_all <- hclust(dist(mat_all),       method = "complete")
colClust_all <- hclust(dist(t(mat_all)),    method = "complete")

# 3) Barra de grupo (factor) — reutiliza sample_info
ann_df <- sample_info %>%
  filter(sample %in% colnames(mat_all)) %>%
  mutate(group = factor(group, levels = c("control","als"))) %>%
  select(group) %>%
  as.data.frame()
rownames(ann_df) <- colnames(mat_all)

ann_cols <- list(group = c(control = "#56B4E9", als = "#E69F00"))

# 4) Breaks seguros
bk <- seq(min(mat_all), max(mat_all), length.out = 101)
if (length(unique(bk)) == 1) bk <- unique(bk) + c(0, 1e-9)

# 5) Heat-map completo
pheatmap(mat_all,
         color              = colorRampPalette(c("white", "#970404"))(100),
         breaks             = bk,
         cluster_rows       = rowClust_all,
         cluster_cols       = colClust_all,
         show_rownames      = FALSE,
         show_colnames      = FALSE,
         annotation_col     = ann_df,
         annotation_colors  = ann_cols,
         main               = "G>T SNVs (toda la secuencia) – Euclidean clustering")
```


```{r}
## STEP 1 ── matriz SNV × muestra  (G>T en semilla 2-7) --------------------


gt_mat_df <- snv_all_clean %>%                     # ← o snv_all_freq
  filter(mut_type == "G>T",
         pos_num >= 2 & pos_num <= 7) %>%          # <- usa & , no coma
  mutate(snv_id = paste(miRNA, `pos:mut`, sep = "_")) %>%  # id único
  group_by(sample, snv_id) %>%                     # colapsa duplicados
  summarise(freq = sum(freq), .groups = "drop") %>%
  pivot_wider(names_from  = sample,
              values_from = freq,
              values_fill = 0) %>%                 # NA → 0
  arrange(snv_id)

mat_snv <- gt_mat_df %>%
  column_to_rownames("snv_id") %>%
  as.matrix()

stopifnot(is.numeric(mat_snv))                     # debe ser numérico
cat("dims SNV×sample :", dim(mat_snv), "\n")
print(head(mat_snv[, 1:5], 3))                     # vistazo rápido
```

```{r}
## STEP 2 ── distancias + hclust  -----------------------------------------
# distancias Euclidianas
rowDist  <- dist(mat_snv,        method = "euclidean")   # SNVs (filas)
colDist  <- dist(t(mat_snv),     method = "euclidean")   # muestras (columnas)

rowClust <- hclust(rowDist, method = "complete")
colClust <- hclust(colDist, method = "complete")

cat("Cluster sizes  filas =", length(rowClust$order),
    "  columnas =", length(colClust$order), "\n")
```




```{r}
## STEP 3 ── annotation bar  ----------------------------------------------
ann <- sample_info %>%
  filter(sample %in% colnames(mat_snv)) %>%
  mutate(group = factor(group, levels = c("control", "als"))) %>% # asegúrate
  arrange(match(sample, colnames(mat_snv))) %>%
  select(group)

rownames(ann) <- colnames(mat_snv)       # ← imprescindible

ann_cols <- list(
  group = c(control = "#56B4E9", als = "#E69F00")   # azul / naranja
)

str(ann)    # confirma que es data-frame con factor
```



```{r}
## CHUNK : heat-map con anotación corregida --------------------------------
library(pheatmap)

# 1) convertir barra → data.frame y forzar columnas a factor
ann_df <- ann %>%               # <- tu tibble con group
  as.data.frame() %>%           # evita warning de row-names
  mutate(across(everything(), ~ as.factor(.x)))

rownames(ann_df) <- colnames(mat_snv)   # imprescindible

# 2) paleta para las columnas de anotación (factores)
ann_cols <- list(
  group = c(control = "#56B4E9", als = "#E69F00")
)

# 3) breaks seguros para la matriz
bk <- seq(min(mat_snv), max(mat_snv), length.out = 101)
if (length(unique(bk)) == 1) bk <- unique(bk) + c(0, 1e-9)

# 4) heat-map
pheatmap(mat_snv,
         color              = colorRampPalette(c("white", "#970404"))(100),
         breaks             = bk,
         cluster_rows       = rowClust,
         cluster_cols       = colClust,
         show_rownames      = FALSE,
         show_colnames      = FALSE,
         annotation_col     = ann_df,          # data.frame, sólo factores
         annotation_colors  = ann_cols,
         main               = "G>T SNVs in seed (nt 2-7) – Euclidean clustering")
```
```{r}
install.packages("BiocManager")
BiocManager::install("ComplexHeatmap")
```


```{r}
############################################################################
##  Heat-map estilo “paper” con ComplexHeatmap  –  G > T (toda secuencia) ##
############################################################################
library(ComplexHeatmap)
library(circlize)
library(dplyr)
library(tidyr)

## ---------- 1. matriz SNV × muestra  ------------------------------------
gt_mat <- snv_all_clean %>%                           # o snv_all_freq
  filter(mut_type == "G>T") %>%                       # toda la secuencia
  mutate(snv_id = paste(miRNA, `pos:mut`, sep = "_")) %>%
  group_by(sample, snv_id, pos_num) %>%               # pos_num p/ barra lateral
  summarise(freq = sum(freq), .groups = "drop") %>%
  pivot_wider(names_from = sample, values_from = freq, values_fill = 0) %>%
  arrange(snv_id)

pos_vector <- gt_mat$pos_num                          # guardar posiciones

mat <- as.matrix(gt_mat[ , -(1:2)])                   # quita snv_id y pos_num
rownames(mat) <- gt_mat$snv_id

## ---------- 2. anotación de muestras (columnas) --------------------------
ann_col <- sample_info %>%
  filter(sample %in% colnames(mat)) %>%
  arrange(match(sample, colnames(mat))) %>%
  mutate(group   = factor(group,   levels = c("control","als")),
         grade   = sample(c("I","II","III"), n(), replace = TRUE),   # DEMO
         survival= runif(n(), 0, 1)) %>%                              # DEMO
  select(group, grade, survival)

ha_col <- HeatmapAnnotation(
  df = ann_col,
  col = list(
    group   = c(control = "#56B4E9", als = "#E69F00"),
    grade   = c(I = "#E6CCFF", II = "#D29BFF", III = "#BE66FF"),
    survival= colorRamp2(c(0, 1), c("grey90", "grey30"))
  ),
  gp = gpar(col = NA)  # sin bordes
)

## ---------- 3. anotación de filas (posición nt) --------------------------
pos_col_fun <- colorRamp2(c(1, 22), c("#FFFFE0", "#FFD700"))  # suave amarillo
ha_row <- rowAnnotation(
  position = anno_simple(pos_vector,
                         col = pos_col_fun,
                         border = NA),
  width = unit(0.4, "cm")
)

## ---------- 4. heat-map principal ----------------------------------------
ht <- Heatmap(
  mat,
  name             = "freq",
  col              = colorRamp2(c(0, 0.015, max(mat)), c("white", "#FFE5E5", "#970404")),
  cluster_rows     = TRUE,
  cluster_columns  = TRUE,
  clustering_distance_rows = "euclidean",
  clustering_distance_columns = "euclidean",
  clustering_method_rows    = "complete",
  clustering_method_columns = "complete",
  show_row_names   = FALSE,
  show_column_names= FALSE,
  top_annotation   = ha_col,
  right_annotation = ha_row,
  column_title     = "G > T SNVs (toda la secuencia)",
  heatmap_width    = unit(9, "cm"),
  heatmap_height   = unit(11, "cm"),
  border           = TRUE
)

draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
```

